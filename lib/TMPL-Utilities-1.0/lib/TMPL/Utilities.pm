package TMPL::Utilities;

=pod

=head1 AUTHOR

Jonathan Cummings

=head1 NAME

Utilities.pm -- Perl module package for TMPL utilities usage

=head1 SYNOPSIS

Usage:

 None

=head1 DESCRIPTION

Utilities.pm contains the general and global subroutines used within the TMPL computing environment.

=head1 SUBROUTINES

Utilities::FileIO ( {input=>$inputName, output=>$outputName} ) -- TBD

Utilities::CreateGraph ({input=>$file, gnu=>$file }) -- Given a GNU plotting file, run GNU Plot with output file name.

=head1 EXIT STATUS

Utilities dies on error, returns TRUE on success.

=head1 Change Log

07/01/2012	Brandon Webb		Added CreateGraph
07/19/2012	Brandon Webb		Schema change for FileIO: default bug

=head1 COPYRIGHT

Copyright 2012 TMPL

Permission is granted to copy, distribute and/or modify this 
document under the terms of the GNU Free Documentation 
License, Version 1.2 or any later version published by the 
Free Software Foundation; with no Invariant Sections, with 
no Front-Cover Texts, and with no Back-Cover Texts.

=cut

use strict;
use warnings;
use lib("~/PerlLib");
use Cwd;
use File::Spec qw(rel2abs);
use File::HomeDir;
use File::Basename;
use Params::Validate qw(:all);
use Data::Dumper::Simple as => 'display', autowarn=>1;


use Exporter qw( import );

our $VERSION     = 1.01;
our @ISA         = qw( Exporter );
our @EXPORT   	 = qw( ValidatePath CreateDefaultOutput CreateDefaultInput FileIO createGraph qsub );
our %EXPORT_TAGS = ( DEFAULT => [qw( ValidatePath CreateDefaultOutput CreateDefaultInput FileIO createGraph qsub )] );

sub qsub{
	my %vars = validate
	(@_,
		{
			job_name => {
				optional => 1,
				type		=> SCALAR
			},
			queue_name => {
				optional => 1,
				type		=> SCALAR
			},
			email => {
				optional => 1,
				type		=> SCALAR
			},
			group => {
				optional => 1,
				type		=> SCALAR
			},
			script => {
				optional => 0,
				type		=> SCALAR
			},
			outdir => {
				optional => 1,
				type		=> SCALAR
			},
			errdir => {
				optional => 1,
				type		=> SCALAR
			},
			variables => {
				optional => 1,
				type		=> HASHREF
			},
			resource_options => {
				optional => 1,
				type 		=> ARRAYREF
			}
		}
	);
	#Initialize vars
	my $job_name = '';
	$job_name = $vars{job_name} if(exists $vars{job_name});
	my $queue_name = '';
	$queue_name = $vars{queue_name} if(exists $vars{queue_name});
	my $email = $vars{email};
	my $group_name = $vars{group};
	my $script = $vars{script};
	my $outdir = $vars{outdir};
	my $errdir = $vars{errdir};
	my $select = '';
	my $ncpus = '';
	my $mem = '';
	my $jobtype = '';
	my $place = '';
	my $walltime = '';
	my $cputime = '';
	my %variables = %{$vars{variables}};

	open (QSUBOPT, '/gsfs2/home/u18/jon24/TMPL/lib/Modules/qsub.opt');
	foreach my $line(<QSUBOPT>){
		$line =~ s/\r//g;
		if($line !~ /^#/){
			if($line =~ /^name\s+(.*)/i){
				$job_name = $1 unless(exists $vars{job_name});
			} elsif($line =~ /^queue\s+(.*)\s+/i){
				$queue_name = $1 unless(exists $vars{queue_name});
			} elsif($line =~ /^email\s+(.*)/i){
				$email = $1 unless(exists $vars{email});
			} elsif($line =~ /^group\s+(.*)/i){
				$group_name = $1 unless(exists $vars{group_name});
			} elsif($line =~ /^outdir\s+(.*)/i){
				$outdir = $1 unless(exists $vars{outdir});
			} elsif($line =~ /^errdir\s+(.*)/i){
				$errdir = $1 unless(exists $vars{errdir});
			} elsif($line =~ /^select\s+(.*)/i){
				$select = $1;
			} elsif($line =~ /^ncpus\s+(.*)/i){
				$ncpus = $1;
			} elsif($line =~ /^mem\s+(.*)/i){
				$mem = $1.'gb';
			} elsif($line =~ /^jobtype\s+(.*)/i){
				$jobtype = $1;
			} elsif($line =~ /^place\s+(.*)/i){
				$place = $1;
			} elsif($line =~ /^walltime\s+(.*)/i){
				$walltime = $1;
			} elsif($line =~ /^cputime\s+(.*)/i){
				$cputime = $1;
			}
		}
	}
	close QSUBOPT;
	
	#Print PBS options header
	print Cwd->getcwd;
	open TEMPSCRIPT, ">", "tempscript.sh" or die $!;
	
	print TEMPSCRIPT "##Automatically generated by TMPL lib.\n";
	print TEMPSCRIPT "#PBS -q $queue_name\n";
	print TEMPSCRIPT "#PBS -m bea\n";
	print TEMPSCRIPT "#PBS -M $email\n";
	print TEMPSCRIPT "#PBS -W group_list=$group_name\n";
	print TEMPSCRIPT "#PBS -o $outdir\n";
	print TEMPSCRIPT "#PBS -e $errdir\n";
	print TEMPSCRIPT "#PBS -V\n";
	print TEMPSCRIPT "#PBS -l select=$select:ncpus=$ncpus:mem=$mem\n" unless($select eq '' or $ncpus eq '' or $mem eq '');
	print TEMPSCRIPT "#PBS -l jobtype=$jobtype\n" unless($jobtype eq '');
	print TEMPSCRIPT "#PBS -l place=$place\n" unless($place eq '');
	print TEMPSCRIPT "#PBS -l walltime=$walltime\n" unless($walltime eq '');
	print TEMPSCRIPT "#PBS -l cputime=$cputime\n" unless($cputime eq '');
	print TEMPSCRIPT "\n\n";
	
	open SCRIPTCONTENTS, "<", $script or die $!;
	foreach my $line(<SCRIPTCONTENTS>){
		print TEMPSCRIPT $line;
	}
	
	close TEMPSCRIPT;
	close SCRIPTCONTENTS;
		
	foreach my $env_var(keys %variables){
		$ENV{uc($env_var)} = $variables{$env_var};
	}
	my $script_path = File::Spec->rel2abs('tempscript.sh');
	my $qsub_call = "qsub -N $job_name $script_path";
	print $qsub_call;
	`$qsub_call`;
	unlink($script_path);
	
}

sub CreateDefaultInput{
	my %vars = validate
	(@_,
		{
			class => {
				optional => 0,
				type		=> SCALAR
			}
		}
	);
	my $class = $vars{class};
	my $working_dir = Cwd->getcwd;
	my $home_dir = File::HomeDir->my_home;
	my $return_path = '';
	
	#Change into the home directory
	chdir($home_dir);
	
	#Check all directories in home directory for directory where name = class name and make it if it doesnt exist
	my @dir_contents = <*>;
	my $found_class_folder = 0;
	foreach(@dir_contents){
		if($_ eq $class){
			chdir($class);
			$found_class_folder = 1;
		}
	}
	if($found_class_folder == 0){
		mkdir($class);
		chdir($class);
	}
	
	#Check inside the class directory for the input directory and make it if it doesnt exist
	@dir_contents = <*>;
	my $found_input_folder = 0;
	foreach(@dir_contents){
		if($_ eq 'input'){
			chdir('input');
			$found_input_folder = 1;
		}
	}
	if($found_input_folder == 0){
		mkdir('input');
		chdir('input');
	}
	
	#return the path that we made or found
	$return_path = Cwd->getcwd;
	
	#Set the current directory back to where we started
	chdir($working_dir);
	
	return $return_path;
	
}

sub CreateDefaultOutput{
	my %vars = validate
	(@_,
		{
			class => {
				optional => 0,
				type		=> SCALAR
			}
		}
	);
	
	my $class = $vars{class};
	my $working_dir = Cwd->getcwd;
	my $home_dir = File::HomeDir->my_home;
	my $return_path = '';
	
	#Check in home directory for class name folder
	chdir($home_dir);
	my @dir_contents = <*>;
	my $found_class_folder = 0;
	foreach(@dir_contents){
		if($_ eq $class){
			$found_class_folder = 1;
			chdir($_);
		}
	}
	
	#If we couldnt find the class folder inside the homedir then create it
	if($found_class_folder == 0){
		mkdir($class);
		chdir($class);
	}
	
	#Check for output folder inside class folder
	@dir_contents = <*>;
	my $found_output_folder = 0;
	foreach(@dir_contents){
		if($_ eq 'output'){
			$found_output_folder = 1;
			chdir($_);
		}
	}
	
	#If we couldnt find the output folder inside the class folder then create it
	if($found_output_folder == 0){
		mkdir('output');
		chdir('output');
	}
	
	#Parse the date
	my @time = localtime(time);
	my $day_of_month = $time[3];
	my $month = $time[4]+1;
	my $year = $time[5]+1900;
	
	my $date_folder_name = $month."-".$day_of_month."-".$year;
	
	#Check for todays date folder inside output folder
	@dir_contents = <*>;
	my $found_date_folder = 0;
	foreach(@dir_contents){
		if($_ eq $date_folder_name){
			$found_date_folder = 1;
			chdir($_);
		}
	}
	
	#If we couldnt find todays date folder create it.
	if($found_date_folder == 0){
		mkdir($date_folder_name);
		chdir($date_folder_name);
	}
	
	#Create the time folder
	my $seconds = $time[0];
	my $minutes = $time[1];
	my $hours = $time[2];
	my $time_folder_name = "HR".$hours.'-MIN'.$minutes.'-SEC'.$seconds;
	mkdir($time_folder_name);
	chdir($time_folder_name);
	
	#Return the path we just created/found for the default output
	$return_path = Cwd->getcwd;
	
	#Switch working directory back to where it started before subroutine was called
	chdir($working_dir);
	
	return $return_path;
}

sub ValidatePath {
	my %vars = validate
	(@_,
		{
			dir => {
				optional => 1,
				type		=> SCALAR
			},
			file => {
				optional => 1,
				type		=> SCALAR
			}
		}
	);
	my %return = ();
	my $home_dir = File::HomeDir->my_home;
	my $dir = $vars{dir} if(exists $vars{dir});
	my $file = $vars{file} if(exists $vars{file});
	my $valid_path = $file;
	
	#check to make sure a file or dir was specified
   if ( $file or $dir ) {
		
		#If that path was specified as a file
		if ( $file ) {
			#If the path given for file is valid how it is, set the return value for it and we are done.
			if ( -e $file and -f $file ) {
				return $file;
			}
			#Else if the path given for file exists with home path prepended and no slash added between homedir and name given and is a file, set return value and done.
			elsif ( -e ( $valid_path = $home_dir . $file ) and -f $valid_path ) {
				return $valid_path;
			}
			#Else if the path given for file exists with home path prepended and unix slash added between homedir and name given and is a file, set return value and done.
			elsif ( -e ( $valid_path = $home_dir . '/' . $file ) and -f $valid_path ) {
				return $valid_path;
			}
			#Otherwise we can't find the file from the path given and we return undef for program to handle.
			else {
				return undef;
			}
		}#End file check

		#If that path was specified as a directory.
		if ( $dir ) {
			#If the path given for the dir is valid as is and is a valid directory, set return value and done.
			if ( -e $dir and -d $dir ) {
				return $dir;
			}
			#Else if the path given for dir exists with home path prepended and it is a valid directory, then set return value and done.
			elsif ( -e ($valid_path = $home_dir . $dir) and -d $valid_path ) {
				return $valid_path;
			}
			#Else if the path given for dir exists with home path prepended and unix slash added between homedir and name given and is a directory, set return value and done.
			elsif ( -e ( $valid_path = $home_dir . '/' . $dir ) and -d $valid_path ) {
				return $valid_path;
			}
			#Otherwise we can't find the dir from the path given and we return error.
			else {
				return undef;
			}
	
		}#end dir check

	} else{
		return undef;
	}
}

sub FileIO {

   my %vars = validate (@_, {
	class => {
	    optional => 1,
	    type     => SCALAR
	},
	input_dir => {
	    optional => 1,
	    type     => SCALAR
	},
	input_file => {
	    optional => 1,
	    type     => SCALAR
	},
	output_dir => {
	    optional => 1,
	    type     => SCALAR
	},
	output_file => {
	    optional => 1,
	    type     => SCALAR
	}
    } );
    
    # Assign variables
    my $class = $vars{class};
    my %return = ();
    my $home_dir = File::HomeDir->my_home;
    my $input_file = exists $vars{input_file} ? $vars{input_file} : '';
    my $input_dir = exists $vars{input_dir} ? $vars{input_dir} : '';
    my $output_file = exists $vars{output_file} ? $vars{output_file} : '';
    my $output_dir = exists $vars{output_dir} ? $vars{output_dir} : '';

    #######################################################################################################################################
    #																	  #
    # 								SCHEMA									  #
    #																	  #
    #######################################################################################################################################
    #																	  #
    # Two cases with two sub-cases:													  #
    #																	  #
    # 1. Input type passed. Or is empty and/or is 2.											  #
    #																	  #
    #    a) input file. or is empty and is b).												  #
    #        - has path															  #
    #		- is full path and exists. otherwise...											  #
    #		- or is sub path (append local path) and exist. otherwise...								  #
    #	     - or is filename (append local path) and exists. otherwise...die "invalid path".						  #
    #																	  #
    #    b) input dir. or is empty and die "no parameters".										  #
    #	    - is full path and exists. otherwise...											  #
    #	    - is sub path (append local path) and exists. otherwise...die "invalid path".						  #
    #																	  #
    # 2. Output type passed. Or is empty and die "no parameters".									  #
    #																	  #
    #    a) output file. or is empty and is b).												  #
    #        - has path															  #
    #		- is full path and is valid path. otherwise...										  #
    #		- or is sub path (append local path) and is valid path. otherwise...							  #
    #	     - or is filename (append local path) and is valid path. otherwise...							  #
    #		-- ask to create dir /<local_dir>/<class_name>/<date>/<time>/<filename> if dir does not exist. Add <filename> otherwise.  #
    #																	  #
    #    b) output dir. or is empty and die "no parameters".										  #
    #	    - is full path and exists. otherwise...											  #
    #	    - is sub path (append local path) and exists. otherwise...									  #
    #	   	-- ask to create dir /<local_dir>/<class_name>/<dir_name> if dir does not exist. Use path otherwise.			  #
    #																	  #
    #######################################################################################################################################
   
	#If an input was given
   if ( $input_file or $input_dir ) {
		
		#If that input was specified as a file
		if ( $input_file ) {
			#If the path given for input_file is valid how it is, set the return value for it and we are done.
			if ( -e $input_file and -r $input_file ) {
				$return{ input_file } = $input_file;
			}
			#Else if the path given for input_file exists with home path prepended and is readable, set return value and done.
			elsif ( -e ( $input_file = $home_dir . $input_file ) and -r $input_file ) {
				$return{ input_file } = $input_file;
			}
			#Otherwise we can't find the input_file from the path given and we return error.
			else {
				die "Invalid input file $input_file provided. Verify file path is correct";
			}
		}#End input_file check

		#If that input was specified as a directory.
		if ( $input_dir ) {
			#If the path given for the input_dir is valid as is and is a valid directory, set return value and done.
			if ( -e $input_dir and -d $input_dir ) {
				$return{ input_dir } = "$input_dir";
			}
			#Else if the path given for input_dir exists with home path prepended and it is a valid directory, then set return value and done.
			elsif ( -e ($input_dir = $home_dir . $input_dir) and -d $input_dir ) {
				$return{ input_dir } = "$input_dir";
			}
			#Otherwise we can't find the input_dir from the path given and we return error.
			else {
				die "Invalid input directory $input_dir provided. Verify directory path is correct";
			}
	
		}#End input_dir check

	}#End input checking

	#If any output path was given
   if ( $output_file or $output_dir ) {
		#Initializing variables
		my ($filename, $path, $suffix) = ( '', '', '' );
		#If the output path was specified as an output file
		if ( $output_file ) {
			($filename, $path, $suffix) = fileparse($output_file);
		}
		#If the output dir was specified as an output file
		if ( $output_dir ){
			($filename, $path, $suffix) = fileparse($output_dir);
		}

	if ( -d $path and $path ne "./" ) { # this checks for the validity of the path and prevents output to working dir

	    if ( $output_file ) {

		if ( -e $output_file and -r $output_file ) { # check if the output file exists
		
		    if ( -t STDOUT ) {
		    	FILEINPUT:

		        print "Output file $filename exists. Overwrite file? (y/n) ";
	 	        my $response = <STDIN>;
		        if ( $response=~/^Y.*$/i ) {
		    	    unlink glob "$output_file";
	 	    	} elsif ( $response=~/^N.*$/i ) {
		    	    print "Continue processing? (y/n) ";
		    	    if ( $response=~/^N.*$/i ) { print "Exiting program...\n" and exit(0); }
		    	} else {
		    	    goto FILEINPUT; 
		        }

		        $return{ output_file } = "$output_file";

		    } else { unlink glob "$output_file"; }

	        } else { $return{ output_file } = "$output_file"; }
	    }

	    if ( $output_dir ) { 

		opendir(DIR, "$output_dir") or die "Unable to open directory  $output_dir: $!";
		my @contents = readdir(DIR);
	        closedir(DIR) or die "Unable to close directory: $!";

		if ( @contents ) {

		    if ( -t STDOUT ) {

		        DIRINPUT:

		    	print "Output directory is not empty. Overwrite directory? (y/n) ";
		    	my $response = <STDIN>;
		    	if ( $response=~/^Y.*$/i ) {
			    foreach( @contents ) { unlink glob "$_"; }
		    	} elsif ( $response=~/^N.*$/i ) {
			    print "Continue processing? (y/n) ";
		    	    if ( $response=~/^N.*$/i ) { print "Exiting program...\n" and exit(0); }
		    	} else {
			    goto DIRINPUT;
		    	}
		    }
		} else { foreach( @contents ) { unlink glob "$_"; } }

		$return{ output_dir } = "$output_dir";
	    }

	} else {

	    my $formatedPath = $home_dir;
 	    my @contents;
	    my @date;
	    my $formattedDate;
	    my $formattedTime;
	    my $out;

	    if ( -t STDOUT ) {

		( $output_file ) ? ( $out = $output_file ) : ( $out = $output_dir );

	        print "Invalid output directory: $out. Use default generated output directory instead? (Y/N). ";
	        my $response = <STDIN>;
	        die "Invalid output directory, please try again using a valid file path\n" unless( defined $response and $response =~ /^Y.*$/i);

	    }	

	    opendir(DIR, "$formatedPath") or die "Unable to open directory  $formatedPath: $!";
	    @contents = readdir(DIR);
	    closedir(DIR) or die "Unable to close directory: $!";

	    $formatedPath .= "/$class";

	    if( @contents ) {
	        foreach( @contents ) {
		    mkdir $formatedPath if( $_ ne $class );
	        }
	    }

	    @date = localtime(time);
	    $date[4] += 1;
	    $date[5] += 1900;
	    $formattedDate = "$date[3]0$date[4]$date[5]";

	    opendir(DIR, "$formatedPath") or die "Unable to open directory  $formatedPath: $!";
	    @contents = readdir(DIR);
	    closedir(DIR) or die "Unable to close directory: $!";

	    $formatedPath .= "/$formattedDate";

	    if( @contents ) {
	        foreach ( @contents ) {
		    mkdir $formatedPath if( $_ ne $formattedDate );
	        }
	    }

	    $formattedTime = "$date[2]$date[1]";

	    opendir(DIR, "$formatedPath") or die "Unable to open directory  $formatedPath: $!";
	    @contents = readdir(DIR);
	    closedir(DIR) or die "Unable to close directory: $!";

	    $formatedPath .=  "/$formattedTime";

	    if( @contents ) {
	        foreach ( @contents ) {
		    mkdir $formatedPath if( $_ ne $formattedTime );
	        }
	    }

	    $formatedPath .= "/$filename" if( $output_file );

	    $return{ output_file } = "$formatedPath" if ( $output_file );
	    $return{ output_dir } = "$formatedPath" if ( $output_dir );	    

	}
    } 

    return %return;	

}

sub createGraph {

   my %vars = validate (@_, {
	class => {
	    optional => 0,
	    TYPE     => SCALAR
	},
	input => {
	    optional => 0,
	    TYPE     => SCALAR
	},
	gnu => {
	    optional => 0,	
	    TYPE     => SCALAR
	}
    } );

    if($^O eq "MSWin32") {
	print "GNU Plotting functionality is only implemented on UNIX.\n
	      Please install and call GNU Plotting on the program's outfile externally\n"
	      and exit(0);
    }

    my $class = $vars{class};
    my $input = $vars{input};
    my $outfile = $vars{gnu}.".png";

    my @date = localtime(time);
    $date[4] += 1;
    $date[5] += 1900;
    my $formattedDate = $date[3].$date[4].$date[5];

    my $title = "$class"."_"."$formattedDate";

    #gnuplot({ 'title'	    => "$title",
    #	      'output type' => 'png',
    #	      'output file' => "$outfile" }, 
    #	    [{ 'title' => 'dataset', 'type' => 'file'}, "$input" ], ) or die "Failed gnuplot to $outfile. $?: $!";

    open(GNUPLOT, "|gnuplot") or die "Failed to pipe GNU Plot";
    print GNUPLOT "set terminal png";
    print GNUPLOT "set output $outfile";
    print GNUPLOT "set data style line";
    print GNUPLOT "set title $title";
    print GNUPLOT "plot $outfile";
    close GNUPLOT or die "Failed to clsoe GNU Plot";
}

1;
